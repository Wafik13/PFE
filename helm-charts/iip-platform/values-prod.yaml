# Production Environment Values for IIP Platform
# High availability, security, and performance optimized configuration

global:
  environment: production
  domain: iip.company.com
  imageRegistry: registry.gitlab.company.com/iip/platform
  imagePullPolicy: IfNotPresent
  storageClass: iip-ssd-retain
  
# Production-grade resource allocation
scada:
  replicaCount: 3
  image:
    tag: "1.0.0"  # Use specific version tags in production
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2
      memory: 2Gi
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  env:
    LOG_LEVEL: INFO
    ENABLE_DEBUG_ENDPOINTS: "false"
    CONNECTION_POOL_SIZE: 20
    MAX_CONCURRENT_REQUESTS: 100
  livenessProbe:
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  readinessProbe:
    initialDelaySeconds: 15
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3

analytics:
  replicaCount: 3
  image:
    tag: "1.0.0"
  resources:
    requests:
      cpu: 1
      memory: 2Gi
    limits:
      cpu: 4
      memory: 4Gi
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 15
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  env:
    LOG_LEVEL: INFO
    BATCH_SIZE: 1000
    WORKER_THREADS: 4
    CACHE_TTL: 300

mlInference:
  replicaCount: 3
  image:
    tag: "1.0.0"
  resources:
    requests:
      cpu: 1
      memory: 4Gi
      nvidia.com/gpu: 1
    limits:
      cpu: 4
      memory: 8Gi
      nvidia.com/gpu: 1
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 60
    targetMemoryUtilizationPercentage: 70
    targetGPUUtilizationPercentage: 80
  env:
    LOG_LEVEL: INFO
    MODEL_CACHE_SIZE: 5
    INFERENCE_TIMEOUT: 30
    BATCH_INFERENCE: "true"
    MAX_BATCH_SIZE: 32

frontend:
  replicaCount: 3
  image:
    tag: "1.0.0"
  resources:
    requests:
      cpu: 200m
      memory: 512Mi
    limits:
      cpu: 1
      memory: 1Gi
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  env:
    NODE_ENV: production
    API_BASE_URL: https://iip.company.com/api
    WEBSOCKET_URL: wss://iip.company.com/ws
    ENABLE_DEBUG: "false"
    CACHE_STATIC_ASSETS: "true"

# High-availability infrastructure components
postgresql:
  auth:
    postgresPassword: "${POSTGRES_PASSWORD}"  # From secret
    database: iip_production
  architecture: replication
  primary:
    persistence:
      enabled: true
      size: 200Gi
      storageClass: iip-ssd-retain
    resources:
      requests:
        cpu: 2
        memory: 4Gi
      limits:
        cpu: 4
        memory: 8Gi
    configuration: |
      max_connections = 200
      shared_buffers = 2GB
      effective_cache_size = 6GB
      maintenance_work_mem = 512MB
      checkpoint_completion_target = 0.9
      wal_buffers = 16MB
      default_statistics_target = 100
      random_page_cost = 1.1
      effective_io_concurrency = 200
      work_mem = 10MB
      min_wal_size = 1GB
      max_wal_size = 4GB
      max_worker_processes = 8
      max_parallel_workers_per_gather = 4
      max_parallel_workers = 8
      max_parallel_maintenance_workers = 4
  readReplicas:
    replicaCount: 2
    persistence:
      enabled: true
      size: 200Gi
      storageClass: iip-ssd-retain
    resources:
      requests:
        cpu: 1
        memory: 2Gi
      limits:
        cpu: 2
        memory: 4Gi
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

redis:
  auth:
    enabled: true
    password: "${REDIS_PASSWORD}"
  architecture: replication
  master:
    persistence:
      enabled: true
      size: 20Gi
      storageClass: iip-ssd-retain
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 1
        memory: 2Gi
    configuration: |
      maxmemory-policy allkeys-lru
      timeout 300
      tcp-keepalive 300
      maxclients 10000
  replica:
    replicaCount: 2
    persistence:
      enabled: true
      size: 20Gi
      storageClass: iip-ssd-retain
    resources:
      requests:
        cpu: 300m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 1Gi
  sentinel:
    enabled: true
    masterSet: mymaster
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

rabbitmq:
  auth:
    username: "${RABBITMQ_USERNAME}"
    password: "${RABBITMQ_PASSWORD}"
  clustering:
    enabled: true
    replicaCount: 3
  persistence:
    enabled: true
    size: 50Gi
    storageClass: iip-ssd-retain
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 1
      memory: 2Gi
  configuration: |
    vm_memory_high_watermark.relative = 0.6
    disk_free_limit.relative = 1.0
    cluster_partition_handling = autoheal
    queue_master_locator = min-masters
    loopback_users.guest = false
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

minio:
  auth:
    rootUser: "${MINIO_ROOT_USER}"
    rootPassword: "${MINIO_ROOT_PASSWORD}"
  mode: distributed
  replicas: 4
  persistence:
    enabled: true
    size: 1Ti
    storageClass: iip-ssd-retain
  resources:
    requests:
      cpu: 1
      memory: 2Gi
    limits:
      cpu: 2
      memory: 4Gi
  configuration: |
    MINIO_CACHE_DRIVES="/tmp/cache1,/tmp/cache2"
    MINIO_CACHE_EXCLUDE="*.pdf,*.doc"
    MINIO_CACHE_QUOTA=80
    MINIO_CACHE_AFTER=3
    MINIO_CACHE_WATERMARK_LOW=70
    MINIO_CACHE_WATERMARK_HIGH=90
  metrics:
    serviceMonitor:
      enabled: true

influxdb:
  auth:
    admin:
      username: "${INFLUXDB_ADMIN_USER}"
      password: "${INFLUXDB_ADMIN_PASSWORD}"
      token: "${INFLUXDB_ADMIN_TOKEN}"
  persistence:
    enabled: true
    size: 500Gi
    storageClass: iip-nvme-retain
  resources:
    requests:
      cpu: 2
      memory: 4Gi
    limits:
      cpu: 4
      memory: 8Gi
  configuration: |
    [http]
      max-concurrent-queries = 100
      max-select-point = 0
      max-select-series = 0
      max-select-buckets = 0
    [data]
      cache-max-memory-size = "2g"
      cache-snapshot-memory-size = "512m"
      cache-snapshot-write-cold-duration = "10m"
      compact-full-write-cold-duration = "4h"
      max-series-per-database = 1000000
      max-values-per-tag = 100000
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

# Production API Gateway configuration
kong:
  env:
    database: postgres
    pg_host: postgresql.iip-infrastructure.svc.cluster.local
    pg_port: 5432
    pg_database: kong
    pg_user: kong
    pg_password: "${KONG_PG_PASSWORD}"
    log_level: notice
    nginx_worker_processes: auto
    nginx_worker_connections: 4096
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2
      memory: 2Gi
  replicaCount: 3
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  plugins:
    - name: rate-limiting
      config:
        minute: 1000
        hour: 10000
    - name: cors
      config:
        origins: ["https://iip.company.com"]
        methods: ["GET", "POST", "PUT", "DELETE"]
        headers: ["Accept", "Authorization", "Content-Type"]
        credentials: true
    - name: jwt
      config:
        secret_is_base64: false
        claims_to_verify: ["exp", "iss", "aud"]
    - name: prometheus
      config:
        per_consumer: true

# Production Service Mesh configuration
istio:
  pilot:
    env:
      PILOT_TRACE_SAMPLING: 1.0  # 1% sampling in production
      PILOT_ENABLE_WORKLOAD_ENTRY_AUTOREGISTRATION: true
    resources:
      requests:
        cpu: 500m
        memory: 2Gi
      limits:
        cpu: 1
        memory: 4Gi
  proxy:
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi
  gateway:
    replicaCount: 3
    autoscaling:
      enabled: true
      minReplicas: 3
      maxReplicas: 10

# Production MLOps components
feast:
  replicaCount: 2
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2
      memory: 2Gi
  env:
    LOG_LEVEL: INFO
    FEAST_USAGE_ENABLED: "true"
    FEAST_TELEMETRY_ENABLED: "false"
  persistence:
    enabled: true
    size: 100Gi
    storageClass: iip-ssd-retain

mlflow:
  replicaCount: 2
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2
      memory: 2Gi
  env:
    MLFLOW_TRACKING_URI: http://mlflow.iip-mlops.svc.cluster.local:5000
    MLFLOW_S3_ENDPOINT_URL: http://minio.iip-infrastructure.svc.cluster.local:9000
    MLFLOW_ARTIFACT_ROOT: s3://mlflow-artifacts
  persistence:
    enabled: true
    size: 200Gi
    storageClass: iip-ssd-retain

argoWorkflows:
  controller:
    replicas: 2
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 1
        memory: 2Gi
    persistence:
      enabled: true
      size: 50Gi
      storageClass: iip-ssd-retain
  server:
    replicas: 2
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 1Gi
    authMode: sso

kserve:
  controller:
    replicas: 2
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 1
        memory: 2Gi
  webhook:
    replicas: 2
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 1Gi

# Production monitoring stack
prometheus:
  server:
    retention: "30d"
    retentionSize: "150GB"
    persistentVolume:
      size: 200Gi
      storageClass: iip-ssd-retain
    resources:
      requests:
        cpu: 1
        memory: 4Gi
      limits:
        cpu: 2
        memory: 8Gi
    replicaCount: 2
    configuration: |
      global:
        scrape_interval: 15s
        evaluation_interval: 15s
        external_labels:
          cluster: 'iip-production'
          environment: 'production'
      rule_files:
        - "/etc/prometheus/rules/*.yml"
      scrape_configs:
        - job_name: 'kubernetes-pods'
          kubernetes_sd_configs:
            - role: pod
          relabel_configs:
            - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
              action: keep
              regex: true
  alertmanager:
    enabled: true
    replicaCount: 2
    persistence:
      enabled: true
      size: 10Gi
      storageClass: iip-ssd-retain
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 1Gi
    configuration:
      global:
        smtp_smarthost: 'smtp.company.com:587'
        smtp_from: 'alerts@company.com'
      route:
        group_by: ['alertname', 'cluster', 'service']
        group_wait: 10s
        group_interval: 10s
        repeat_interval: 1h
        receiver: 'web.hook'
      receivers:
        - name: 'web.hook'
          webhook_configs:
            - url: 'http://alertmanager-webhook:5000/'

grafana:
  persistence:
    enabled: true
    size: 20Gi
    storageClass: iip-ssd-retain
  resources:
    requests:
      cpu: 200m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1Gi
  replicaCount: 2
  adminPassword: "${GRAFANA_ADMIN_PASSWORD}"
  env:
    GF_LOG_LEVEL: info
    GF_USERS_ALLOW_SIGN_UP: "false"
    GF_AUTH_ANONYMOUS_ENABLED: "false"
    GF_SECURITY_ADMIN_PASSWORD: "${GRAFANA_ADMIN_PASSWORD}"
    GF_INSTALL_PLUGINS: "grafana-piechart-panel,grafana-worldmap-panel"
  datasources:
    - name: Prometheus
      type: prometheus
      url: http://prometheus-server:80
      access: proxy
      isDefault: true
    - name: InfluxDB
      type: influxdb
      url: http://influxdb:8086
      database: iip_production

# Production security settings
security:
  jwt:
    secret: "${JWT_SECRET}"
    issuer: iip-production
    audience: iip-production-users
    expirationTime: 8h
    algorithm: RS256
  cors:
    allowedOrigins:
      - "https://iip.company.com"
    allowedMethods:
      - GET
      - POST
      - PUT
      - DELETE
    allowCredentials: true
    maxAge: 86400
  networkPolicies:
    enabled: true
    defaultDeny: true
  podSecurityPolicy:
    enabled: true
  rbac:
    enabled: true
    strictMode: true

# Production ingress configuration
ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/hsts: "true"
    nginx.ingress.kubernetes.io/hsts-max-age: "31536000"
    nginx.ingress.kubernetes.io/hsts-include-subdomains: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
  hosts:
    - host: iip.company.com
      paths:
        - path: /
          pathType: Prefix
          service:
            name: frontend
            port: 80
        - path: /api
          pathType: Prefix
          service:
            name: kong-proxy
            port: 80
  tls:
    - secretName: iip-prod-tls
      hosts:
        - iip.company.com

# Production persistent volumes
persistentVolumes:
  storageClass: iip-ssd-retain
  accessMode: ReadWriteOnce
  reclaimPolicy: Retain
  backupPolicy: daily

# Production node affinity
nodeAffinity:
  enabled: true
  requiredDuringScheduling: true
  preferredDuringScheduling: true

# Pod disruption budgets
podDisruptionBudget:
  enabled: true
  minAvailable: 2

# Production-specific features
production:
  highAvailability: true
  backupEnabled: true
  monitoringEnabled: true
  alertingEnabled: true
  auditLogging: true
  encryptionAtRest: true
  encryptionInTransit: true
  networkSegmentation: true
  accessLogging: true

# External services (production endpoints)
externalServices:
  mqtt:
    broker: mqtts://prod-mqtt-broker:8883
    username: "${MQTT_USERNAME}"
    password: "${MQTT_PASSWORD}"
    tls: true
    caFile: /etc/ssl/certs/mqtt-ca.crt
  opcua:
    endpoint: opc.tcp://prod-opcua-server:4840
    username: "${OPCUA_USERNAME}"
    password: "${OPCUA_PASSWORD}"
    security: SignAndEncrypt
    certificate: /etc/ssl/certs/opcua-client.crt
    privateKey: /etc/ssl/private/opcua-client.key
  weather:
    apiKey: "${WEATHER_API_KEY}"
    endpoint: https://api.openweathermap.org/data/2.5
    timeout: 30s
    retries: 3

# Backup configuration
backup:
  enabled: true
  schedule: "0 2 * * *"  # Daily at 2 AM
  retention: 30  # Keep 30 days
  destinations:
    - s3://iip-backups-prod/
    - azure://iip-backups/
  encryption: true
  compression: true

# Disaster recovery
disasterRecovery:
  enabled: true
  replicationFactor: 3
  crossRegionBackup: true
  rto: 4h  # Recovery Time Objective
  rpo: 1h  # Recovery Point Objective

# Compliance settings
compliance:
  iso27001: true
  iec62443: true
  sox: true
  gdpr: true
  auditLogging: true
  dataRetention: 7y
  encryptionStandard: AES-256